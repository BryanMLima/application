import os, hashlib
import fnmatch
import random
from OpenSSL import crypto, SSL
from flask import Flask, render_template, request, redirect
from werkzeug.utils import secure_filename
# from Crypto.PublicKey import RSA

app = Flask(__name__)
# Create folders to help separate files per funcionality
os.makedirs(os.path.join(app.instance_path, "hashcode"), exist_ok=True)
# Create folder to store keys
path_to_keys = os.path.join(app.instance_path, "keys")
# Create folder to store root ca certificate and private key
path_to_ca_root = os.path.join(app.instance_path, "ca_root")
# Create folder to store certificates generated by the Root CA
path_to_cert = os.path.join(app.instance_path, "certificates")

@app.route("/")
def home():  
    return render_template("index.html") 

@app.route("/readfile")  
def read():  
    return render_template("upload.html")

@app.route("/hashcode", methods = ["POST"])  
def hashcode():  
    if request.method == "POST":
        f = request.files["file"]
        # Temporarily save file to generate hashcode
        hashcode = hash_function(f)
        return render_template("content.html", text = hashcode)

@app.route("/generate_keys", methods = ["POST", "GET"])
def generate_keys():
    if request.method == "POST":
        # Sets the size of the RSA Key
        size = request.form.get("size", type = int) 
        key = crypto.PKey()
        key.generate_key(crypto.TYPE_RSA, size)

        private_key = crypto.dump_privatekey(crypto.FILETYPE_PEM,key)
        # Auto selects the private key filename accordingly to not overwrite
        existing_files = fnmatch.filter((f for f in os.listdir(path_to_keys)), "private_*.pem")
        path_pvt = path_to_keys + "/private_key_%d.pem" % (len(existing_files) + 1)
        file_out = open(path_pvt,"wb")
        file_out.write(private_key)
        file_out.close()

        # Auto selects the public key filename accordingly to not overwrite
        public_key = crypto.dump_publickey(crypto.FILETYPE_PEM, key)
        existing_files = fnmatch.filter((f for f in os.listdir(path_to_keys)), "public_*.pem")
        path_pub = path_to_keys + "/public_key_%d.pem" % (len(existing_files) + 1)
        file_out = open(path_pub, "wb")
        file_out.write(public_key)
        file_out.close()

        return render_template("keys_generated.html", path_pub = path_pub, path_pvt = path_pvt)
    else:
        return render_template("generate_keys.html")

@app.route("/certificates_list")
def list_certificates():
    # Arrays to list the serial numbers, subjects and filenames
    certificates = []
    serial_numbers = []
    subjects = []
    for filename in os.listdir(path_to_cert):
        cert_file = open(path_to_cert+"/"+filename, "rt").read()
        certificates.append(filename)
        cert = crypto.load_certificate(crypto.FILETYPE_PEM, cert_file)
        subjects.append(cert.get_subject().CN)
        serial_numbers.append(cert.get_serial_number())
    
    return render_template("/certificates_list.html", len = len(certificates), Certificate = certificates, Serial_Number = serial_numbers, Subject = subjects)

@app.route("/keys_generated")
def keys_generated():
    # Message showing that the keys were generated
    return render_template("keys_generated.html")

@app.route("/generate_certificates", methods = ["POST", "GET"])
def generate_certificates():
    if request.method == "POST":
        certificate_path = path_to_ca_root+"/ca_certificate.pem"
        # Check if CA root certificate exist
        if not(os.path.isfile(certificate_path)):
            # Generate certificates if root ca certificate already exist
            create_root_ca()
            return render_template("generate_certificates.html")
        else:
            cert_req, expiration, path_pvt = create_certificate_request()
            create_certificate(cert_req, expiration)
            return  render_template("certificate_generated.html", path_pvt = path_pvt)
    else:
        # Check if CA root certificate doesnt exist, then generate it
        certificate_path = path_to_ca_root+"/ca_certificate.pem"
        if not(os.path.isfile(certificate_path)):
            return render_template("root_ca_certificate.html")
        # CA root certificate already exist
        else:
            return render_template("generate_certificates.html")

def create_certificate(cert_req, expiration):
    # Get Root CA certificate
    cert_file = open(path_to_ca_root+"/ca_certificate.pem", "rt").read()
    ca_root_cert = crypto.load_certificate(crypto.FILETYPE_PEM, cert_file)
    # Get Root CA private key
    ca_private_key = open(path_to_ca_root+"/ca_private_key.pem", "rt").read()
    ca_root_private_key = crypto.load_privatekey(crypto.FILETYPE_PEM,ca_private_key)

    # Create X509 certificate
    cert = crypto.X509()
    cert.set_serial_number(random.randint(1, 1000000000))
    cert.gmtime_adj_notBefore(0)
    cert.gmtime_adj_notAfter(expiration)
    cert.set_issuer(ca_root_cert.get_subject())
    cert.set_subject(cert_req.get_subject())
    cert.set_pubkey(cert_req.get_pubkey())
    cert.sign(ca_root_private_key, "sha256")

    # Save certificate file
    existing_files = fnmatch.filter((f for f in os.listdir(path_to_cert)), "certificate_*.pem")
    filename = path_to_cert + "/certificate_%d.pem" % (len(existing_files) + 1)
    cert_file = open(filename, "wb")
    cert_file.write(crypto.dump_certificate(crypto.FILETYPE_PEM, cert))
    cert_file.close()

def create_certificate_request():
    subject = request.form.get("subject")
    expiration = request.form.get("expiration", type = int)
    size = request.form.get("size", type = int)
    key = crypto.PKey()
    # Generate key 
    key.generate_key(crypto.TYPE_RSA, size)

    # Creating a certificate request object
    cert_req = crypto.X509Req()
    cert_req.get_subject().CN = subject
    cert_req.set_pubkey(key)
    cert_req.sign(key, "sha256")

    # Save private key file without overwriting
    existing_files = fnmatch.filter((f for f in os.listdir(path_to_keys)), "private_*.pem")
    path_pvt = path_to_keys + "/private_key_%d.pem" % (len(existing_files) + 1)
    key_file = open(path_pvt, "wb")
    key_file.write(crypto.dump_privatekey(crypto.FILETYPE_PEM, key))
    key_file.close()

    return cert_req, expiration, path_pvt

def create_root_ca():
    subject = request.form.get("subject")
    expiration = request.form.get("expiration", type = int)
    size = request.form.get("size", type = int)
    key = crypto.PKey()
    # Generate key 
    key.generate_key(crypto.TYPE_RSA, size)

    # Creating a self signed certificate
    certificate = crypto.X509()
    certificate.get_subject().CN = subject
    # Serial number is random due to be unique and more secure
    certificate.set_serial_number(random.randint(1000000000, 1000000000))
    certificate.set_issuer(certificate.get_subject())
    certificate.gmtime_adj_notBefore(0)
    certificate.gmtime_adj_notAfter(expiration)
    certificate.set_pubkey(key)
    certificate.sign(key, "sha256")

    # Save certificate file
    cert_file = open(path_to_ca_root+"/ca_certificate.pem", "wb")
    cert_file.write(crypto.dump_certificate(crypto.FILETYPE_PEM, certificate))
    cert_file.close()

    # Save private key file
    key_file = open(path_to_ca_root+"/ca_private_key.pem", "wb")
    key_file.write(crypto.dump_privatekey(crypto.FILETYPE_PEM, key))
    key_file.close()

def hash_function(f):
    BLOCK_SIZE = 65536
    # Absolute path to file
    file = os.path.join(app.instance_path, "hashcode", secure_filename(f.filename))
    f.save(file)
    file_hash = hashlib.sha256()
    # Read the file in chunks to use less RAM for the process
    with open(file, "rb") as f:
        fb = f.read(BLOCK_SIZE)
        while len(fb) > 0:
            # Update the hash object
            file_hash.update(fb) 
            fb = f.read(BLOCK_SIZE)
    os.remove(file)
    return file_hash.hexdigest()
    
if __name__ == "__main__":  
    app.run(debug = True)